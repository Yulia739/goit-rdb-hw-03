Кількість рядків:
INNER JOIN: 518
LEFT JOIN: 518
RIGHT JOIN: 518

У даних усі зовнішні ключі мають відповідники.
Тому кожен рядок із order_details знаходить свій order, product, і далі всі довідники — результат однаковий для INNER/LEFT/RIGHT.

RIGHT-JOIN запит був дуже повільним і вантажив CPU:
- Невдалий порядок з’єднань. 
  Суцільний ланцюжок RIGHT від «широких» таблиць створює великі проміжні набори (NULL-розширені рядки) ще до того, як оптимізатор зможе їх “звузити”.

- Індекси. Якщо на полях з’єднання немає індексів (особливо на order_details.order_id, order_details.product_id та FK у orders, products), 
  MySQL робить повні сканування і величезну кількість порівнянь.

- COUNT(*) не магічний. Для підрахунку все одно треба пройти всі зіставлені рядки; коли проміжний набір великий — CPU і час ростуть.

- RIGHT ускладнює старт. Оптимізатору важче почати з “правильного” боку; той самий запит, але з “якорем” на найдетальнішій таблиці (order_details) 
  та далі INNER-JOIN, дає значно кращий план.